// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BehaviorPB.proto

#ifndef PROTOBUF_BehaviorPB_2eproto__INCLUDED
#define PROTOBUF_BehaviorPB_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace BehaviorPB {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BehaviorPB_2eproto();
void protobuf_AssignDesc_BehaviorPB_2eproto();
void protobuf_ShutdownFile_BehaviorPB_2eproto();

class Selector;
class Sequence;
class Parallel;
class Action;
class Condition;
class Link;
class DecoratorNot;
class DecoratorLoop;
class DecoratorCounter;
class DecoratorTimer;
class DecoratorRand;
class Node;
class Node_Editor;
class Tree;
class Tree_Editor;

enum Action_Type {
  Action_Type_Null = 0,
  Action_Type_CntTest2_2 = 992,
  Action_Type_CntTest0 = 993,
  Action_Type_CntTest1 = 994,
  Action_Type_CntTest2 = 995,
  Action_Type_CntTest = 996,
  Action_Type_Printf = 999
};
bool Action_Type_IsValid(int value);
const Action_Type Action_Type_Type_MIN = Action_Type_Null;
const Action_Type Action_Type_Type_MAX = Action_Type_Printf;
const int Action_Type_Type_ARRAYSIZE = Action_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Action_Type_descriptor();
inline const ::std::string& Action_Type_Name(Action_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Action_Type_descriptor(), value);
}
inline bool Action_Type_Parse(
    const ::std::string& name, Action_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Action_Type>(
    Action_Type_descriptor(), name, value);
}
enum Condition_Type {
  Condition_Type_Null = 0,
  Condition_Type_Printf = 998
};
bool Condition_Type_IsValid(int value);
const Condition_Type Condition_Type_Type_MIN = Condition_Type_Null;
const Condition_Type Condition_Type_Type_MAX = Condition_Type_Printf;
const int Condition_Type_Type_ARRAYSIZE = Condition_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Condition_Type_descriptor();
inline const ::std::string& Condition_Type_Name(Condition_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Condition_Type_descriptor(), value);
}
inline bool Condition_Type_Parse(
    const ::std::string& name, Condition_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Condition_Type>(
    Condition_Type_descriptor(), name, value);
}
enum DecoratorCounter_Type {
  DecoratorCounter_Type_Null = 0,
  DecoratorCounter_Type_Printf = 997
};
bool DecoratorCounter_Type_IsValid(int value);
const DecoratorCounter_Type DecoratorCounter_Type_Type_MIN = DecoratorCounter_Type_Null;
const DecoratorCounter_Type DecoratorCounter_Type_Type_MAX = DecoratorCounter_Type_Printf;
const int DecoratorCounter_Type_Type_ARRAYSIZE = DecoratorCounter_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* DecoratorCounter_Type_descriptor();
inline const ::std::string& DecoratorCounter_Type_Name(DecoratorCounter_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    DecoratorCounter_Type_descriptor(), value);
}
inline bool DecoratorCounter_Type_Parse(
    const ::std::string& name, DecoratorCounter_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecoratorCounter_Type>(
    DecoratorCounter_Type_descriptor(), name, value);
}
enum NodeType {
  NodeType_Null = 0,
  NodeType_Selector = 1,
  NodeType_Sequence = 2,
  NodeType_Parallel = 3,
  NodeType_Action = 4,
  NodeType_Condition = 5,
  NodeType_Link = 6,
  NodeType_Decorator = 7,
  NodeType_DecoratorNot = 8,
  NodeType_DecoratorLoop = 9,
  NodeType_DecoratorCounter = 10,
  NodeType_DecoratorTimer = 11,
  NodeType_DecoratorRand = 12,
  NodeType_CntTestAction2_2 = 992,
  NodeType_CntTestAction0 = 993,
  NodeType_CntTestAction1 = 994,
  NodeType_CntTestAction2 = 995,
  NodeType_CntTestAction = 996,
  NodeType_PrintfDecoratorCounter = 997,
  NodeType_PrintfCondtion = 998,
  NodeType_PrintfAction = 999
};
bool NodeType_IsValid(int value);
const NodeType NodeType_MIN = NodeType_Null;
const NodeType NodeType_MAX = NodeType_PrintfAction;
const int NodeType_ARRAYSIZE = NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeType_descriptor();
inline const ::std::string& NodeType_Name(NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeType_descriptor(), value);
}
inline bool NodeType_Parse(
    const ::std::string& name, NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeType>(
    NodeType_descriptor(), name, value);
}
enum ParallelPolicy {
  ParallelPolicy_FailOnAll = 0,
  ParallelPolicy_SuccOnAll = 1
};
bool ParallelPolicy_IsValid(int value);
const ParallelPolicy ParallelPolicy_MIN = ParallelPolicy_FailOnAll;
const ParallelPolicy ParallelPolicy_MAX = ParallelPolicy_SuccOnAll;
const int ParallelPolicy_ARRAYSIZE = ParallelPolicy_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParallelPolicy_descriptor();
inline const ::std::string& ParallelPolicy_Name(ParallelPolicy value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParallelPolicy_descriptor(), value);
}
inline bool ParallelPolicy_Parse(
    const ::std::string& name, ParallelPolicy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParallelPolicy>(
    ParallelPolicy_descriptor(), name, value);
}
// ===================================================================

class Selector : public ::google::protobuf::Message {
 public:
  Selector();
  virtual ~Selector();

  Selector(const Selector& from);

  inline Selector& operator=(const Selector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Selector& default_instance();

  void Swap(Selector* other);

  // implements Message ----------------------------------------------

  Selector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Selector& from);
  void MergeFrom(const Selector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:BehaviorPB.Selector)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Selector* default_instance_;
};
// -------------------------------------------------------------------

class Sequence : public ::google::protobuf::Message {
 public:
  Sequence();
  virtual ~Sequence();

  Sequence(const Sequence& from);

  inline Sequence& operator=(const Sequence& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sequence& default_instance();

  void Swap(Sequence* other);

  // implements Message ----------------------------------------------

  Sequence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sequence& from);
  void MergeFrom(const Sequence& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:BehaviorPB.Sequence)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Sequence* default_instance_;
};
// -------------------------------------------------------------------

class Parallel : public ::google::protobuf::Message {
 public:
  Parallel();
  virtual ~Parallel();

  Parallel(const Parallel& from);

  inline Parallel& operator=(const Parallel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parallel& default_instance();

  void Swap(Parallel* other);

  // implements Message ----------------------------------------------

  Parallel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parallel& from);
  void MergeFrom(const Parallel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .BehaviorPB.ParallelPolicy policy = 1;
  inline bool has_policy() const;
  inline void clear_policy();
  static const int kPolicyFieldNumber = 1;
  inline ::BehaviorPB::ParallelPolicy policy() const;
  inline void set_policy(::BehaviorPB::ParallelPolicy value);

  // @@protoc_insertion_point(class_scope:BehaviorPB.Parallel)
 private:
  inline void set_has_policy();
  inline void clear_has_policy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int policy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Parallel* default_instance_;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  void Swap(Action* other);

  // implements Message ----------------------------------------------

  Action* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Action_Type Type;
  static const Type Null = Action_Type_Null;
  static const Type CntTest2_2 = Action_Type_CntTest2_2;
  static const Type CntTest0 = Action_Type_CntTest0;
  static const Type CntTest1 = Action_Type_CntTest1;
  static const Type CntTest2 = Action_Type_CntTest2;
  static const Type CntTest = Action_Type_CntTest;
  static const Type Printf = Action_Type_Printf;
  static inline bool Type_IsValid(int value) {
    return Action_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Action_Type_Type_MIN;
  static const Type Type_MAX =
    Action_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Action_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Action_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Action_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Action_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string script_path = 1;
  inline bool has_script_path() const;
  inline void clear_script_path();
  static const int kScriptPathFieldNumber = 1;
  inline const ::std::string& script_path() const;
  inline void set_script_path(const ::std::string& value);
  inline void set_script_path(const char* value);
  inline void set_script_path(const char* value, size_t size);
  inline ::std::string* mutable_script_path();
  inline ::std::string* release_script_path();
  inline void set_allocated_script_path(::std::string* script_path);

  // @@protoc_insertion_point(class_scope:BehaviorPB.Action)
 private:
  inline void set_has_script_path();
  inline void clear_has_script_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* script_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Action* default_instance_;
};
// -------------------------------------------------------------------

class Condition : public ::google::protobuf::Message {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();

  void Swap(Condition* other);

  // implements Message ----------------------------------------------

  Condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Condition_Type Type;
  static const Type Null = Condition_Type_Null;
  static const Type Printf = Condition_Type_Printf;
  static inline bool Type_IsValid(int value) {
    return Condition_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Condition_Type_Type_MIN;
  static const Type Type_MAX =
    Condition_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Condition_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Condition_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Condition_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Condition_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string script_path = 1;
  inline bool has_script_path() const;
  inline void clear_script_path();
  static const int kScriptPathFieldNumber = 1;
  inline const ::std::string& script_path() const;
  inline void set_script_path(const ::std::string& value);
  inline void set_script_path(const char* value);
  inline void set_script_path(const char* value, size_t size);
  inline ::std::string* mutable_script_path();
  inline ::std::string* release_script_path();
  inline void set_allocated_script_path(::std::string* script_path);

  // @@protoc_insertion_point(class_scope:BehaviorPB.Condition)
 private:
  inline void set_has_script_path();
  inline void clear_has_script_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* script_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Condition* default_instance_;
};
// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message {
 public:
  Link();
  virtual ~Link();

  Link(const Link& from);

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();

  void Swap(Link* other);

  // implements Message ----------------------------------------------

  Link* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sub_tree_name = 1;
  inline bool has_sub_tree_name() const;
  inline void clear_sub_tree_name();
  static const int kSubTreeNameFieldNumber = 1;
  inline const ::std::string& sub_tree_name() const;
  inline void set_sub_tree_name(const ::std::string& value);
  inline void set_sub_tree_name(const char* value);
  inline void set_sub_tree_name(const char* value, size_t size);
  inline ::std::string* mutable_sub_tree_name();
  inline ::std::string* release_sub_tree_name();
  inline void set_allocated_sub_tree_name(::std::string* sub_tree_name);

  // @@protoc_insertion_point(class_scope:BehaviorPB.Link)
 private:
  inline void set_has_sub_tree_name();
  inline void clear_has_sub_tree_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sub_tree_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Link* default_instance_;
};
// -------------------------------------------------------------------

class DecoratorNot : public ::google::protobuf::Message {
 public:
  DecoratorNot();
  virtual ~DecoratorNot();

  DecoratorNot(const DecoratorNot& from);

  inline DecoratorNot& operator=(const DecoratorNot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecoratorNot& default_instance();

  void Swap(DecoratorNot* other);

  // implements Message ----------------------------------------------

  DecoratorNot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecoratorNot& from);
  void MergeFrom(const DecoratorNot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:BehaviorPB.DecoratorNot)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static DecoratorNot* default_instance_;
};
// -------------------------------------------------------------------

class DecoratorLoop : public ::google::protobuf::Message {
 public:
  DecoratorLoop();
  virtual ~DecoratorLoop();

  DecoratorLoop(const DecoratorLoop& from);

  inline DecoratorLoop& operator=(const DecoratorLoop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecoratorLoop& default_instance();

  void Swap(DecoratorLoop* other);

  // implements Message ----------------------------------------------

  DecoratorLoop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecoratorLoop& from);
  void MergeFrom(const DecoratorLoop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 loop_cnt = 1;
  inline bool has_loop_cnt() const;
  inline void clear_loop_cnt();
  static const int kLoopCntFieldNumber = 1;
  inline ::google::protobuf::int32 loop_cnt() const;
  inline void set_loop_cnt(::google::protobuf::int32 value);

  // required string loop_key = 2;
  inline bool has_loop_key() const;
  inline void clear_loop_key();
  static const int kLoopKeyFieldNumber = 2;
  inline const ::std::string& loop_key() const;
  inline void set_loop_key(const ::std::string& value);
  inline void set_loop_key(const char* value);
  inline void set_loop_key(const char* value, size_t size);
  inline ::std::string* mutable_loop_key();
  inline ::std::string* release_loop_key();
  inline void set_allocated_loop_key(::std::string* loop_key);

  // required string bb_i = 3;
  inline bool has_bb_i() const;
  inline void clear_bb_i();
  static const int kBbIFieldNumber = 3;
  inline const ::std::string& bb_i() const;
  inline void set_bb_i(const ::std::string& value);
  inline void set_bb_i(const char* value);
  inline void set_bb_i(const char* value, size_t size);
  inline ::std::string* mutable_bb_i();
  inline ::std::string* release_bb_i();
  inline void set_allocated_bb_i(::std::string* bb_i);

  // @@protoc_insertion_point(class_scope:BehaviorPB.DecoratorLoop)
 private:
  inline void set_has_loop_cnt();
  inline void clear_has_loop_cnt();
  inline void set_has_loop_key();
  inline void clear_has_loop_key();
  inline void set_has_bb_i();
  inline void clear_has_bb_i();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* loop_key_;
  ::std::string* bb_i_;
  ::google::protobuf::int32 loop_cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static DecoratorLoop* default_instance_;
};
// -------------------------------------------------------------------

class DecoratorCounter : public ::google::protobuf::Message {
 public:
  DecoratorCounter();
  virtual ~DecoratorCounter();

  DecoratorCounter(const DecoratorCounter& from);

  inline DecoratorCounter& operator=(const DecoratorCounter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecoratorCounter& default_instance();

  void Swap(DecoratorCounter* other);

  // implements Message ----------------------------------------------

  DecoratorCounter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecoratorCounter& from);
  void MergeFrom(const DecoratorCounter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef DecoratorCounter_Type Type;
  static const Type Null = DecoratorCounter_Type_Null;
  static const Type Printf = DecoratorCounter_Type_Printf;
  static inline bool Type_IsValid(int value) {
    return DecoratorCounter_Type_IsValid(value);
  }
  static const Type Type_MIN =
    DecoratorCounter_Type_Type_MIN;
  static const Type Type_MAX =
    DecoratorCounter_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    DecoratorCounter_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return DecoratorCounter_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return DecoratorCounter_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return DecoratorCounter_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 limit_cnt = 1;
  inline bool has_limit_cnt() const;
  inline void clear_limit_cnt();
  static const int kLimitCntFieldNumber = 1;
  inline ::google::protobuf::int32 limit_cnt() const;
  inline void set_limit_cnt(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BehaviorPB.DecoratorCounter)
 private:
  inline void set_has_limit_cnt();
  inline void clear_has_limit_cnt();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 limit_cnt_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static DecoratorCounter* default_instance_;
};
// -------------------------------------------------------------------

class DecoratorTimer : public ::google::protobuf::Message {
 public:
  DecoratorTimer();
  virtual ~DecoratorTimer();

  DecoratorTimer(const DecoratorTimer& from);

  inline DecoratorTimer& operator=(const DecoratorTimer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecoratorTimer& default_instance();

  void Swap(DecoratorTimer* other);

  // implements Message ----------------------------------------------

  DecoratorTimer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecoratorTimer& from);
  void MergeFrom(const DecoratorTimer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 elpase = 1;
  inline bool has_elpase() const;
  inline void clear_elpase();
  static const int kElpaseFieldNumber = 1;
  inline ::google::protobuf::int32 elpase() const;
  inline void set_elpase(::google::protobuf::int32 value);

  // required int32 start = 2;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 2;
  inline ::google::protobuf::int32 start() const;
  inline void set_start(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:BehaviorPB.DecoratorTimer)
 private:
  inline void set_has_elpase();
  inline void clear_has_elpase();
  inline void set_has_start();
  inline void clear_has_start();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 elpase_;
  ::google::protobuf::int32 start_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static DecoratorTimer* default_instance_;
};
// -------------------------------------------------------------------

class DecoratorRand : public ::google::protobuf::Message {
 public:
  DecoratorRand();
  virtual ~DecoratorRand();

  DecoratorRand(const DecoratorRand& from);

  inline DecoratorRand& operator=(const DecoratorRand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecoratorRand& default_instance();

  void Swap(DecoratorRand* other);

  // implements Message ----------------------------------------------

  DecoratorRand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DecoratorRand& from);
  void MergeFrom(const DecoratorRand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 r_idx = 1;
  inline bool has_r_idx() const;
  inline void clear_r_idx();
  static const int kRIdxFieldNumber = 1;
  inline ::google::protobuf::int32 r_idx() const;
  inline void set_r_idx(::google::protobuf::int32 value);

  // required int32 r_begin = 2;
  inline bool has_r_begin() const;
  inline void clear_r_begin();
  static const int kRBeginFieldNumber = 2;
  inline ::google::protobuf::int32 r_begin() const;
  inline void set_r_begin(::google::protobuf::int32 value);

  // required int32 r_end = 3;
  inline bool has_r_end() const;
  inline void clear_r_end();
  static const int kREndFieldNumber = 3;
  inline ::google::protobuf::int32 r_end() const;
  inline void set_r_end(::google::protobuf::int32 value);

  // repeated int32 choose_arr = 4;
  inline int choose_arr_size() const;
  inline void clear_choose_arr();
  static const int kChooseArrFieldNumber = 4;
  inline ::google::protobuf::int32 choose_arr(int index) const;
  inline void set_choose_arr(int index, ::google::protobuf::int32 value);
  inline void add_choose_arr(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      choose_arr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_choose_arr();

  // required string bb_rnd = 5;
  inline bool has_bb_rnd() const;
  inline void clear_bb_rnd();
  static const int kBbRndFieldNumber = 5;
  inline const ::std::string& bb_rnd() const;
  inline void set_bb_rnd(const ::std::string& value);
  inline void set_bb_rnd(const char* value);
  inline void set_bb_rnd(const char* value, size_t size);
  inline ::std::string* mutable_bb_rnd();
  inline ::std::string* release_bb_rnd();
  inline void set_allocated_bb_rnd(::std::string* bb_rnd);

  // @@protoc_insertion_point(class_scope:BehaviorPB.DecoratorRand)
 private:
  inline void set_has_r_idx();
  inline void clear_has_r_idx();
  inline void set_has_r_begin();
  inline void clear_has_r_begin();
  inline void set_has_r_end();
  inline void clear_has_r_end();
  inline void set_has_bb_rnd();
  inline void clear_has_bb_rnd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 r_idx_;
  ::google::protobuf::int32 r_begin_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > choose_arr_;
  ::std::string* bb_rnd_;
  ::google::protobuf::int32 r_end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static DecoratorRand* default_instance_;
};
// -------------------------------------------------------------------

class Node_Editor : public ::google::protobuf::Message {
 public:
  Node_Editor();
  virtual ~Node_Editor();

  Node_Editor(const Node_Editor& from);

  inline Node_Editor& operator=(const Node_Editor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node_Editor& default_instance();

  void Swap(Node_Editor* other);

  // implements Message ----------------------------------------------

  Node_Editor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node_Editor& from);
  void MergeFrom(const Node_Editor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:BehaviorPB.Node.Editor)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* name_;
  ::std::string* desc_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Node_Editor* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Node_Editor Editor;

  // accessors -------------------------------------------------------

  // optional .BehaviorPB.Node.Editor editor = 1;
  inline bool has_editor() const;
  inline void clear_editor();
  static const int kEditorFieldNumber = 1;
  inline const ::BehaviorPB::Node_Editor& editor() const;
  inline ::BehaviorPB::Node_Editor* mutable_editor();
  inline ::BehaviorPB::Node_Editor* release_editor();
  inline void set_allocated_editor(::BehaviorPB::Node_Editor* editor);

  // repeated .BehaviorPB.Node nodes = 2;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 2;
  inline const ::BehaviorPB::Node& nodes(int index) const;
  inline ::BehaviorPB::Node* mutable_nodes(int index);
  inline ::BehaviorPB::Node* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::BehaviorPB::Node >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::BehaviorPB::Node >*
      mutable_nodes();

  // required .BehaviorPB.NodeType type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::BehaviorPB::NodeType type() const;
  inline void set_type(::BehaviorPB::NodeType value);

  // optional .BehaviorPB.Selector selector = 4;
  inline bool has_selector() const;
  inline void clear_selector();
  static const int kSelectorFieldNumber = 4;
  inline const ::BehaviorPB::Selector& selector() const;
  inline ::BehaviorPB::Selector* mutable_selector();
  inline ::BehaviorPB::Selector* release_selector();
  inline void set_allocated_selector(::BehaviorPB::Selector* selector);

  // optional .BehaviorPB.Sequence sequence = 5;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 5;
  inline const ::BehaviorPB::Sequence& sequence() const;
  inline ::BehaviorPB::Sequence* mutable_sequence();
  inline ::BehaviorPB::Sequence* release_sequence();
  inline void set_allocated_sequence(::BehaviorPB::Sequence* sequence);

  // optional .BehaviorPB.Parallel parallel = 6;
  inline bool has_parallel() const;
  inline void clear_parallel();
  static const int kParallelFieldNumber = 6;
  inline const ::BehaviorPB::Parallel& parallel() const;
  inline ::BehaviorPB::Parallel* mutable_parallel();
  inline ::BehaviorPB::Parallel* release_parallel();
  inline void set_allocated_parallel(::BehaviorPB::Parallel* parallel);

  // optional .BehaviorPB.Action action = 7;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 7;
  inline const ::BehaviorPB::Action& action() const;
  inline ::BehaviorPB::Action* mutable_action();
  inline ::BehaviorPB::Action* release_action();
  inline void set_allocated_action(::BehaviorPB::Action* action);

  // optional .BehaviorPB.Condition condition = 8;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 8;
  inline const ::BehaviorPB::Condition& condition() const;
  inline ::BehaviorPB::Condition* mutable_condition();
  inline ::BehaviorPB::Condition* release_condition();
  inline void set_allocated_condition(::BehaviorPB::Condition* condition);

  // optional .BehaviorPB.Link link = 9;
  inline bool has_link() const;
  inline void clear_link();
  static const int kLinkFieldNumber = 9;
  inline const ::BehaviorPB::Link& link() const;
  inline ::BehaviorPB::Link* mutable_link();
  inline ::BehaviorPB::Link* release_link();
  inline void set_allocated_link(::BehaviorPB::Link* link);

  // optional .BehaviorPB.DecoratorNot d_not = 10;
  inline bool has_d_not() const;
  inline void clear_d_not();
  static const int kDNotFieldNumber = 10;
  inline const ::BehaviorPB::DecoratorNot& d_not() const;
  inline ::BehaviorPB::DecoratorNot* mutable_d_not();
  inline ::BehaviorPB::DecoratorNot* release_d_not();
  inline void set_allocated_d_not(::BehaviorPB::DecoratorNot* d_not);

  // optional .BehaviorPB.DecoratorLoop d_loop = 11;
  inline bool has_d_loop() const;
  inline void clear_d_loop();
  static const int kDLoopFieldNumber = 11;
  inline const ::BehaviorPB::DecoratorLoop& d_loop() const;
  inline ::BehaviorPB::DecoratorLoop* mutable_d_loop();
  inline ::BehaviorPB::DecoratorLoop* release_d_loop();
  inline void set_allocated_d_loop(::BehaviorPB::DecoratorLoop* d_loop);

  // optional .BehaviorPB.DecoratorCounter d_counter = 12;
  inline bool has_d_counter() const;
  inline void clear_d_counter();
  static const int kDCounterFieldNumber = 12;
  inline const ::BehaviorPB::DecoratorCounter& d_counter() const;
  inline ::BehaviorPB::DecoratorCounter* mutable_d_counter();
  inline ::BehaviorPB::DecoratorCounter* release_d_counter();
  inline void set_allocated_d_counter(::BehaviorPB::DecoratorCounter* d_counter);

  // optional .BehaviorPB.DecoratorTimer d_timer = 13;
  inline bool has_d_timer() const;
  inline void clear_d_timer();
  static const int kDTimerFieldNumber = 13;
  inline const ::BehaviorPB::DecoratorTimer& d_timer() const;
  inline ::BehaviorPB::DecoratorTimer* mutable_d_timer();
  inline ::BehaviorPB::DecoratorTimer* release_d_timer();
  inline void set_allocated_d_timer(::BehaviorPB::DecoratorTimer* d_timer);

  // optional .BehaviorPB.DecoratorRand d_rand = 14;
  inline bool has_d_rand() const;
  inline void clear_d_rand();
  static const int kDRandFieldNumber = 14;
  inline const ::BehaviorPB::DecoratorRand& d_rand() const;
  inline ::BehaviorPB::DecoratorRand* mutable_d_rand();
  inline ::BehaviorPB::DecoratorRand* release_d_rand();
  inline void set_allocated_d_rand(::BehaviorPB::DecoratorRand* d_rand);

  // @@protoc_insertion_point(class_scope:BehaviorPB.Node)
 private:
  inline void set_has_editor();
  inline void clear_has_editor();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_selector();
  inline void clear_has_selector();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_parallel();
  inline void clear_has_parallel();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_link();
  inline void clear_has_link();
  inline void set_has_d_not();
  inline void clear_has_d_not();
  inline void set_has_d_loop();
  inline void clear_has_d_loop();
  inline void set_has_d_counter();
  inline void clear_has_d_counter();
  inline void set_has_d_timer();
  inline void clear_has_d_timer();
  inline void set_has_d_rand();
  inline void clear_has_d_rand();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::BehaviorPB::Node_Editor* editor_;
  ::google::protobuf::RepeatedPtrField< ::BehaviorPB::Node > nodes_;
  ::BehaviorPB::Selector* selector_;
  ::BehaviorPB::Sequence* sequence_;
  ::BehaviorPB::Parallel* parallel_;
  ::BehaviorPB::Action* action_;
  ::BehaviorPB::Condition* condition_;
  ::BehaviorPB::Link* link_;
  ::BehaviorPB::DecoratorNot* d_not_;
  ::BehaviorPB::DecoratorLoop* d_loop_;
  ::BehaviorPB::DecoratorCounter* d_counter_;
  ::BehaviorPB::DecoratorTimer* d_timer_;
  ::BehaviorPB::DecoratorRand* d_rand_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Tree_Editor : public ::google::protobuf::Message {
 public:
  Tree_Editor();
  virtual ~Tree_Editor();

  Tree_Editor(const Tree_Editor& from);

  inline Tree_Editor& operator=(const Tree_Editor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tree_Editor& default_instance();

  void Swap(Tree_Editor* other);

  // implements Message ----------------------------------------------

  Tree_Editor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tree_Editor& from);
  void MergeFrom(const Tree_Editor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string desc = 1;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 1;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:BehaviorPB.Tree.Editor)
 private:
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* desc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Tree_Editor* default_instance_;
};
// -------------------------------------------------------------------

class Tree : public ::google::protobuf::Message {
 public:
  Tree();
  virtual ~Tree();

  Tree(const Tree& from);

  inline Tree& operator=(const Tree& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tree& default_instance();

  void Swap(Tree* other);

  // implements Message ----------------------------------------------

  Tree* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tree& from);
  void MergeFrom(const Tree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Tree_Editor Editor;

  // accessors -------------------------------------------------------

  // optional .BehaviorPB.Tree.Editor editor = 1;
  inline bool has_editor() const;
  inline void clear_editor();
  static const int kEditorFieldNumber = 1;
  inline const ::BehaviorPB::Tree_Editor& editor() const;
  inline ::BehaviorPB::Tree_Editor* mutable_editor();
  inline ::BehaviorPB::Tree_Editor* release_editor();
  inline void set_allocated_editor(::BehaviorPB::Tree_Editor* editor);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .BehaviorPB.Node root = 3;
  inline bool has_root() const;
  inline void clear_root();
  static const int kRootFieldNumber = 3;
  inline const ::BehaviorPB::Node& root() const;
  inline ::BehaviorPB::Node* mutable_root();
  inline ::BehaviorPB::Node* release_root();
  inline void set_allocated_root(::BehaviorPB::Node* root);

  // @@protoc_insertion_point(class_scope:BehaviorPB.Tree)
 private:
  inline void set_has_editor();
  inline void clear_has_editor();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_root();
  inline void clear_has_root();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::BehaviorPB::Tree_Editor* editor_;
  ::std::string* name_;
  ::BehaviorPB::Node* root_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_BehaviorPB_2eproto();
  friend void protobuf_AssignDesc_BehaviorPB_2eproto();
  friend void protobuf_ShutdownFile_BehaviorPB_2eproto();

  void InitAsDefaultInstance();
  static Tree* default_instance_;
};
// ===================================================================


// ===================================================================

// Selector

// -------------------------------------------------------------------

// Sequence

// -------------------------------------------------------------------

// Parallel

// required .BehaviorPB.ParallelPolicy policy = 1;
inline bool Parallel::has_policy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parallel::set_has_policy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parallel::clear_has_policy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parallel::clear_policy() {
  policy_ = 0;
  clear_has_policy();
}
inline ::BehaviorPB::ParallelPolicy Parallel::policy() const {
  return static_cast< ::BehaviorPB::ParallelPolicy >(policy_);
}
inline void Parallel::set_policy(::BehaviorPB::ParallelPolicy value) {
  assert(::BehaviorPB::ParallelPolicy_IsValid(value));
  set_has_policy();
  policy_ = value;
}

// -------------------------------------------------------------------

// Action

// required string script_path = 1;
inline bool Action::has_script_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Action::set_has_script_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Action::clear_has_script_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Action::clear_script_path() {
  if (script_path_ != &::google::protobuf::internal::kEmptyString) {
    script_path_->clear();
  }
  clear_has_script_path();
}
inline const ::std::string& Action::script_path() const {
  return *script_path_;
}
inline void Action::set_script_path(const ::std::string& value) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(value);
}
inline void Action::set_script_path(const char* value) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(value);
}
inline void Action::set_script_path(const char* value, size_t size) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Action::mutable_script_path() {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    script_path_ = new ::std::string;
  }
  return script_path_;
}
inline ::std::string* Action::release_script_path() {
  clear_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_path_;
    script_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Action::set_allocated_script_path(::std::string* script_path) {
  if (script_path_ != &::google::protobuf::internal::kEmptyString) {
    delete script_path_;
  }
  if (script_path) {
    set_has_script_path();
    script_path_ = script_path;
  } else {
    clear_has_script_path();
    script_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Condition

// required string script_path = 1;
inline bool Condition::has_script_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::set_has_script_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Condition::clear_has_script_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Condition::clear_script_path() {
  if (script_path_ != &::google::protobuf::internal::kEmptyString) {
    script_path_->clear();
  }
  clear_has_script_path();
}
inline const ::std::string& Condition::script_path() const {
  return *script_path_;
}
inline void Condition::set_script_path(const ::std::string& value) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(value);
}
inline void Condition::set_script_path(const char* value) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(value);
}
inline void Condition::set_script_path(const char* value, size_t size) {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    script_path_ = new ::std::string;
  }
  script_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Condition::mutable_script_path() {
  set_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    script_path_ = new ::std::string;
  }
  return script_path_;
}
inline ::std::string* Condition::release_script_path() {
  clear_has_script_path();
  if (script_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = script_path_;
    script_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Condition::set_allocated_script_path(::std::string* script_path) {
  if (script_path_ != &::google::protobuf::internal::kEmptyString) {
    delete script_path_;
  }
  if (script_path) {
    set_has_script_path();
    script_path_ = script_path;
  } else {
    clear_has_script_path();
    script_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Link

// required string sub_tree_name = 1;
inline bool Link::has_sub_tree_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Link::set_has_sub_tree_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Link::clear_has_sub_tree_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Link::clear_sub_tree_name() {
  if (sub_tree_name_ != &::google::protobuf::internal::kEmptyString) {
    sub_tree_name_->clear();
  }
  clear_has_sub_tree_name();
}
inline const ::std::string& Link::sub_tree_name() const {
  return *sub_tree_name_;
}
inline void Link::set_sub_tree_name(const ::std::string& value) {
  set_has_sub_tree_name();
  if (sub_tree_name_ == &::google::protobuf::internal::kEmptyString) {
    sub_tree_name_ = new ::std::string;
  }
  sub_tree_name_->assign(value);
}
inline void Link::set_sub_tree_name(const char* value) {
  set_has_sub_tree_name();
  if (sub_tree_name_ == &::google::protobuf::internal::kEmptyString) {
    sub_tree_name_ = new ::std::string;
  }
  sub_tree_name_->assign(value);
}
inline void Link::set_sub_tree_name(const char* value, size_t size) {
  set_has_sub_tree_name();
  if (sub_tree_name_ == &::google::protobuf::internal::kEmptyString) {
    sub_tree_name_ = new ::std::string;
  }
  sub_tree_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Link::mutable_sub_tree_name() {
  set_has_sub_tree_name();
  if (sub_tree_name_ == &::google::protobuf::internal::kEmptyString) {
    sub_tree_name_ = new ::std::string;
  }
  return sub_tree_name_;
}
inline ::std::string* Link::release_sub_tree_name() {
  clear_has_sub_tree_name();
  if (sub_tree_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sub_tree_name_;
    sub_tree_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Link::set_allocated_sub_tree_name(::std::string* sub_tree_name) {
  if (sub_tree_name_ != &::google::protobuf::internal::kEmptyString) {
    delete sub_tree_name_;
  }
  if (sub_tree_name) {
    set_has_sub_tree_name();
    sub_tree_name_ = sub_tree_name;
  } else {
    clear_has_sub_tree_name();
    sub_tree_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DecoratorNot

// -------------------------------------------------------------------

// DecoratorLoop

// required int32 loop_cnt = 1;
inline bool DecoratorLoop::has_loop_cnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecoratorLoop::set_has_loop_cnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecoratorLoop::clear_has_loop_cnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecoratorLoop::clear_loop_cnt() {
  loop_cnt_ = 0;
  clear_has_loop_cnt();
}
inline ::google::protobuf::int32 DecoratorLoop::loop_cnt() const {
  return loop_cnt_;
}
inline void DecoratorLoop::set_loop_cnt(::google::protobuf::int32 value) {
  set_has_loop_cnt();
  loop_cnt_ = value;
}

// required string loop_key = 2;
inline bool DecoratorLoop::has_loop_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecoratorLoop::set_has_loop_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecoratorLoop::clear_has_loop_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecoratorLoop::clear_loop_key() {
  if (loop_key_ != &::google::protobuf::internal::kEmptyString) {
    loop_key_->clear();
  }
  clear_has_loop_key();
}
inline const ::std::string& DecoratorLoop::loop_key() const {
  return *loop_key_;
}
inline void DecoratorLoop::set_loop_key(const ::std::string& value) {
  set_has_loop_key();
  if (loop_key_ == &::google::protobuf::internal::kEmptyString) {
    loop_key_ = new ::std::string;
  }
  loop_key_->assign(value);
}
inline void DecoratorLoop::set_loop_key(const char* value) {
  set_has_loop_key();
  if (loop_key_ == &::google::protobuf::internal::kEmptyString) {
    loop_key_ = new ::std::string;
  }
  loop_key_->assign(value);
}
inline void DecoratorLoop::set_loop_key(const char* value, size_t size) {
  set_has_loop_key();
  if (loop_key_ == &::google::protobuf::internal::kEmptyString) {
    loop_key_ = new ::std::string;
  }
  loop_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DecoratorLoop::mutable_loop_key() {
  set_has_loop_key();
  if (loop_key_ == &::google::protobuf::internal::kEmptyString) {
    loop_key_ = new ::std::string;
  }
  return loop_key_;
}
inline ::std::string* DecoratorLoop::release_loop_key() {
  clear_has_loop_key();
  if (loop_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = loop_key_;
    loop_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DecoratorLoop::set_allocated_loop_key(::std::string* loop_key) {
  if (loop_key_ != &::google::protobuf::internal::kEmptyString) {
    delete loop_key_;
  }
  if (loop_key) {
    set_has_loop_key();
    loop_key_ = loop_key;
  } else {
    clear_has_loop_key();
    loop_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string bb_i = 3;
inline bool DecoratorLoop::has_bb_i() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecoratorLoop::set_has_bb_i() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecoratorLoop::clear_has_bb_i() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecoratorLoop::clear_bb_i() {
  if (bb_i_ != &::google::protobuf::internal::kEmptyString) {
    bb_i_->clear();
  }
  clear_has_bb_i();
}
inline const ::std::string& DecoratorLoop::bb_i() const {
  return *bb_i_;
}
inline void DecoratorLoop::set_bb_i(const ::std::string& value) {
  set_has_bb_i();
  if (bb_i_ == &::google::protobuf::internal::kEmptyString) {
    bb_i_ = new ::std::string;
  }
  bb_i_->assign(value);
}
inline void DecoratorLoop::set_bb_i(const char* value) {
  set_has_bb_i();
  if (bb_i_ == &::google::protobuf::internal::kEmptyString) {
    bb_i_ = new ::std::string;
  }
  bb_i_->assign(value);
}
inline void DecoratorLoop::set_bb_i(const char* value, size_t size) {
  set_has_bb_i();
  if (bb_i_ == &::google::protobuf::internal::kEmptyString) {
    bb_i_ = new ::std::string;
  }
  bb_i_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DecoratorLoop::mutable_bb_i() {
  set_has_bb_i();
  if (bb_i_ == &::google::protobuf::internal::kEmptyString) {
    bb_i_ = new ::std::string;
  }
  return bb_i_;
}
inline ::std::string* DecoratorLoop::release_bb_i() {
  clear_has_bb_i();
  if (bb_i_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bb_i_;
    bb_i_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DecoratorLoop::set_allocated_bb_i(::std::string* bb_i) {
  if (bb_i_ != &::google::protobuf::internal::kEmptyString) {
    delete bb_i_;
  }
  if (bb_i) {
    set_has_bb_i();
    bb_i_ = bb_i;
  } else {
    clear_has_bb_i();
    bb_i_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DecoratorCounter

// required int32 limit_cnt = 1;
inline bool DecoratorCounter::has_limit_cnt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecoratorCounter::set_has_limit_cnt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecoratorCounter::clear_has_limit_cnt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecoratorCounter::clear_limit_cnt() {
  limit_cnt_ = 0;
  clear_has_limit_cnt();
}
inline ::google::protobuf::int32 DecoratorCounter::limit_cnt() const {
  return limit_cnt_;
}
inline void DecoratorCounter::set_limit_cnt(::google::protobuf::int32 value) {
  set_has_limit_cnt();
  limit_cnt_ = value;
}

// -------------------------------------------------------------------

// DecoratorTimer

// required int32 elpase = 1;
inline bool DecoratorTimer::has_elpase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecoratorTimer::set_has_elpase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecoratorTimer::clear_has_elpase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecoratorTimer::clear_elpase() {
  elpase_ = 0;
  clear_has_elpase();
}
inline ::google::protobuf::int32 DecoratorTimer::elpase() const {
  return elpase_;
}
inline void DecoratorTimer::set_elpase(::google::protobuf::int32 value) {
  set_has_elpase();
  elpase_ = value;
}

// required int32 start = 2;
inline bool DecoratorTimer::has_start() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecoratorTimer::set_has_start() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecoratorTimer::clear_has_start() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecoratorTimer::clear_start() {
  start_ = 0;
  clear_has_start();
}
inline ::google::protobuf::int32 DecoratorTimer::start() const {
  return start_;
}
inline void DecoratorTimer::set_start(::google::protobuf::int32 value) {
  set_has_start();
  start_ = value;
}

// -------------------------------------------------------------------

// DecoratorRand

// required int32 r_idx = 1;
inline bool DecoratorRand::has_r_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecoratorRand::set_has_r_idx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecoratorRand::clear_has_r_idx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecoratorRand::clear_r_idx() {
  r_idx_ = 0;
  clear_has_r_idx();
}
inline ::google::protobuf::int32 DecoratorRand::r_idx() const {
  return r_idx_;
}
inline void DecoratorRand::set_r_idx(::google::protobuf::int32 value) {
  set_has_r_idx();
  r_idx_ = value;
}

// required int32 r_begin = 2;
inline bool DecoratorRand::has_r_begin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecoratorRand::set_has_r_begin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DecoratorRand::clear_has_r_begin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DecoratorRand::clear_r_begin() {
  r_begin_ = 0;
  clear_has_r_begin();
}
inline ::google::protobuf::int32 DecoratorRand::r_begin() const {
  return r_begin_;
}
inline void DecoratorRand::set_r_begin(::google::protobuf::int32 value) {
  set_has_r_begin();
  r_begin_ = value;
}

// required int32 r_end = 3;
inline bool DecoratorRand::has_r_end() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecoratorRand::set_has_r_end() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DecoratorRand::clear_has_r_end() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DecoratorRand::clear_r_end() {
  r_end_ = 0;
  clear_has_r_end();
}
inline ::google::protobuf::int32 DecoratorRand::r_end() const {
  return r_end_;
}
inline void DecoratorRand::set_r_end(::google::protobuf::int32 value) {
  set_has_r_end();
  r_end_ = value;
}

// repeated int32 choose_arr = 4;
inline int DecoratorRand::choose_arr_size() const {
  return choose_arr_.size();
}
inline void DecoratorRand::clear_choose_arr() {
  choose_arr_.Clear();
}
inline ::google::protobuf::int32 DecoratorRand::choose_arr(int index) const {
  return choose_arr_.Get(index);
}
inline void DecoratorRand::set_choose_arr(int index, ::google::protobuf::int32 value) {
  choose_arr_.Set(index, value);
}
inline void DecoratorRand::add_choose_arr(::google::protobuf::int32 value) {
  choose_arr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DecoratorRand::choose_arr() const {
  return choose_arr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DecoratorRand::mutable_choose_arr() {
  return &choose_arr_;
}

// required string bb_rnd = 5;
inline bool DecoratorRand::has_bb_rnd() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DecoratorRand::set_has_bb_rnd() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DecoratorRand::clear_has_bb_rnd() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DecoratorRand::clear_bb_rnd() {
  if (bb_rnd_ != &::google::protobuf::internal::kEmptyString) {
    bb_rnd_->clear();
  }
  clear_has_bb_rnd();
}
inline const ::std::string& DecoratorRand::bb_rnd() const {
  return *bb_rnd_;
}
inline void DecoratorRand::set_bb_rnd(const ::std::string& value) {
  set_has_bb_rnd();
  if (bb_rnd_ == &::google::protobuf::internal::kEmptyString) {
    bb_rnd_ = new ::std::string;
  }
  bb_rnd_->assign(value);
}
inline void DecoratorRand::set_bb_rnd(const char* value) {
  set_has_bb_rnd();
  if (bb_rnd_ == &::google::protobuf::internal::kEmptyString) {
    bb_rnd_ = new ::std::string;
  }
  bb_rnd_->assign(value);
}
inline void DecoratorRand::set_bb_rnd(const char* value, size_t size) {
  set_has_bb_rnd();
  if (bb_rnd_ == &::google::protobuf::internal::kEmptyString) {
    bb_rnd_ = new ::std::string;
  }
  bb_rnd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DecoratorRand::mutable_bb_rnd() {
  set_has_bb_rnd();
  if (bb_rnd_ == &::google::protobuf::internal::kEmptyString) {
    bb_rnd_ = new ::std::string;
  }
  return bb_rnd_;
}
inline ::std::string* DecoratorRand::release_bb_rnd() {
  clear_has_bb_rnd();
  if (bb_rnd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bb_rnd_;
    bb_rnd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DecoratorRand::set_allocated_bb_rnd(::std::string* bb_rnd) {
  if (bb_rnd_ != &::google::protobuf::internal::kEmptyString) {
    delete bb_rnd_;
  }
  if (bb_rnd) {
    set_has_bb_rnd();
    bb_rnd_ = bb_rnd;
  } else {
    clear_has_bb_rnd();
    bb_rnd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Node_Editor

// required int32 id = 1;
inline bool Node_Editor::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node_Editor::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node_Editor::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node_Editor::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Node_Editor::id() const {
  return id_;
}
inline void Node_Editor::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string key = 2;
inline bool Node_Editor::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node_Editor::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node_Editor::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node_Editor::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Node_Editor::key() const {
  return *key_;
}
inline void Node_Editor::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Node_Editor::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Node_Editor::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node_Editor::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Node_Editor::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node_Editor::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool Node_Editor::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node_Editor::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node_Editor::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node_Editor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Node_Editor::name() const {
  return *name_;
}
inline void Node_Editor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Node_Editor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Node_Editor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node_Editor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Node_Editor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node_Editor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string desc = 4;
inline bool Node_Editor::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node_Editor::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node_Editor::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node_Editor::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Node_Editor::desc() const {
  return *desc_;
}
inline void Node_Editor::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Node_Editor::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Node_Editor::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Node_Editor::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* Node_Editor::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Node_Editor::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Node

// optional .BehaviorPB.Node.Editor editor = 1;
inline bool Node::has_editor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_editor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_editor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_editor() {
  if (editor_ != NULL) editor_->::BehaviorPB::Node_Editor::Clear();
  clear_has_editor();
}
inline const ::BehaviorPB::Node_Editor& Node::editor() const {
  return editor_ != NULL ? *editor_ : *default_instance_->editor_;
}
inline ::BehaviorPB::Node_Editor* Node::mutable_editor() {
  set_has_editor();
  if (editor_ == NULL) editor_ = new ::BehaviorPB::Node_Editor;
  return editor_;
}
inline ::BehaviorPB::Node_Editor* Node::release_editor() {
  clear_has_editor();
  ::BehaviorPB::Node_Editor* temp = editor_;
  editor_ = NULL;
  return temp;
}
inline void Node::set_allocated_editor(::BehaviorPB::Node_Editor* editor) {
  delete editor_;
  editor_ = editor;
  if (editor) {
    set_has_editor();
  } else {
    clear_has_editor();
  }
}

// repeated .BehaviorPB.Node nodes = 2;
inline int Node::nodes_size() const {
  return nodes_.size();
}
inline void Node::clear_nodes() {
  nodes_.Clear();
}
inline const ::BehaviorPB::Node& Node::nodes(int index) const {
  return nodes_.Get(index);
}
inline ::BehaviorPB::Node* Node::mutable_nodes(int index) {
  return nodes_.Mutable(index);
}
inline ::BehaviorPB::Node* Node::add_nodes() {
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BehaviorPB::Node >&
Node::nodes() const {
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::BehaviorPB::Node >*
Node::mutable_nodes() {
  return &nodes_;
}

// required .BehaviorPB.NodeType type = 3;
inline bool Node::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::BehaviorPB::NodeType Node::type() const {
  return static_cast< ::BehaviorPB::NodeType >(type_);
}
inline void Node::set_type(::BehaviorPB::NodeType value) {
  assert(::BehaviorPB::NodeType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .BehaviorPB.Selector selector = 4;
inline bool Node::has_selector() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_selector() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_selector() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_selector() {
  if (selector_ != NULL) selector_->::BehaviorPB::Selector::Clear();
  clear_has_selector();
}
inline const ::BehaviorPB::Selector& Node::selector() const {
  return selector_ != NULL ? *selector_ : *default_instance_->selector_;
}
inline ::BehaviorPB::Selector* Node::mutable_selector() {
  set_has_selector();
  if (selector_ == NULL) selector_ = new ::BehaviorPB::Selector;
  return selector_;
}
inline ::BehaviorPB::Selector* Node::release_selector() {
  clear_has_selector();
  ::BehaviorPB::Selector* temp = selector_;
  selector_ = NULL;
  return temp;
}
inline void Node::set_allocated_selector(::BehaviorPB::Selector* selector) {
  delete selector_;
  selector_ = selector;
  if (selector) {
    set_has_selector();
  } else {
    clear_has_selector();
  }
}

// optional .BehaviorPB.Sequence sequence = 5;
inline bool Node::has_sequence() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Node::set_has_sequence() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Node::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Node::clear_sequence() {
  if (sequence_ != NULL) sequence_->::BehaviorPB::Sequence::Clear();
  clear_has_sequence();
}
inline const ::BehaviorPB::Sequence& Node::sequence() const {
  return sequence_ != NULL ? *sequence_ : *default_instance_->sequence_;
}
inline ::BehaviorPB::Sequence* Node::mutable_sequence() {
  set_has_sequence();
  if (sequence_ == NULL) sequence_ = new ::BehaviorPB::Sequence;
  return sequence_;
}
inline ::BehaviorPB::Sequence* Node::release_sequence() {
  clear_has_sequence();
  ::BehaviorPB::Sequence* temp = sequence_;
  sequence_ = NULL;
  return temp;
}
inline void Node::set_allocated_sequence(::BehaviorPB::Sequence* sequence) {
  delete sequence_;
  sequence_ = sequence;
  if (sequence) {
    set_has_sequence();
  } else {
    clear_has_sequence();
  }
}

// optional .BehaviorPB.Parallel parallel = 6;
inline bool Node::has_parallel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Node::set_has_parallel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Node::clear_has_parallel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Node::clear_parallel() {
  if (parallel_ != NULL) parallel_->::BehaviorPB::Parallel::Clear();
  clear_has_parallel();
}
inline const ::BehaviorPB::Parallel& Node::parallel() const {
  return parallel_ != NULL ? *parallel_ : *default_instance_->parallel_;
}
inline ::BehaviorPB::Parallel* Node::mutable_parallel() {
  set_has_parallel();
  if (parallel_ == NULL) parallel_ = new ::BehaviorPB::Parallel;
  return parallel_;
}
inline ::BehaviorPB::Parallel* Node::release_parallel() {
  clear_has_parallel();
  ::BehaviorPB::Parallel* temp = parallel_;
  parallel_ = NULL;
  return temp;
}
inline void Node::set_allocated_parallel(::BehaviorPB::Parallel* parallel) {
  delete parallel_;
  parallel_ = parallel;
  if (parallel) {
    set_has_parallel();
  } else {
    clear_has_parallel();
  }
}

// optional .BehaviorPB.Action action = 7;
inline bool Node::has_action() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Node::set_has_action() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Node::clear_has_action() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Node::clear_action() {
  if (action_ != NULL) action_->::BehaviorPB::Action::Clear();
  clear_has_action();
}
inline const ::BehaviorPB::Action& Node::action() const {
  return action_ != NULL ? *action_ : *default_instance_->action_;
}
inline ::BehaviorPB::Action* Node::mutable_action() {
  set_has_action();
  if (action_ == NULL) action_ = new ::BehaviorPB::Action;
  return action_;
}
inline ::BehaviorPB::Action* Node::release_action() {
  clear_has_action();
  ::BehaviorPB::Action* temp = action_;
  action_ = NULL;
  return temp;
}
inline void Node::set_allocated_action(::BehaviorPB::Action* action) {
  delete action_;
  action_ = action;
  if (action) {
    set_has_action();
  } else {
    clear_has_action();
  }
}

// optional .BehaviorPB.Condition condition = 8;
inline bool Node::has_condition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Node::set_has_condition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Node::clear_has_condition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Node::clear_condition() {
  if (condition_ != NULL) condition_->::BehaviorPB::Condition::Clear();
  clear_has_condition();
}
inline const ::BehaviorPB::Condition& Node::condition() const {
  return condition_ != NULL ? *condition_ : *default_instance_->condition_;
}
inline ::BehaviorPB::Condition* Node::mutable_condition() {
  set_has_condition();
  if (condition_ == NULL) condition_ = new ::BehaviorPB::Condition;
  return condition_;
}
inline ::BehaviorPB::Condition* Node::release_condition() {
  clear_has_condition();
  ::BehaviorPB::Condition* temp = condition_;
  condition_ = NULL;
  return temp;
}
inline void Node::set_allocated_condition(::BehaviorPB::Condition* condition) {
  delete condition_;
  condition_ = condition;
  if (condition) {
    set_has_condition();
  } else {
    clear_has_condition();
  }
}

// optional .BehaviorPB.Link link = 9;
inline bool Node::has_link() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Node::set_has_link() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Node::clear_has_link() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Node::clear_link() {
  if (link_ != NULL) link_->::BehaviorPB::Link::Clear();
  clear_has_link();
}
inline const ::BehaviorPB::Link& Node::link() const {
  return link_ != NULL ? *link_ : *default_instance_->link_;
}
inline ::BehaviorPB::Link* Node::mutable_link() {
  set_has_link();
  if (link_ == NULL) link_ = new ::BehaviorPB::Link;
  return link_;
}
inline ::BehaviorPB::Link* Node::release_link() {
  clear_has_link();
  ::BehaviorPB::Link* temp = link_;
  link_ = NULL;
  return temp;
}
inline void Node::set_allocated_link(::BehaviorPB::Link* link) {
  delete link_;
  link_ = link;
  if (link) {
    set_has_link();
  } else {
    clear_has_link();
  }
}

// optional .BehaviorPB.DecoratorNot d_not = 10;
inline bool Node::has_d_not() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Node::set_has_d_not() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Node::clear_has_d_not() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Node::clear_d_not() {
  if (d_not_ != NULL) d_not_->::BehaviorPB::DecoratorNot::Clear();
  clear_has_d_not();
}
inline const ::BehaviorPB::DecoratorNot& Node::d_not() const {
  return d_not_ != NULL ? *d_not_ : *default_instance_->d_not_;
}
inline ::BehaviorPB::DecoratorNot* Node::mutable_d_not() {
  set_has_d_not();
  if (d_not_ == NULL) d_not_ = new ::BehaviorPB::DecoratorNot;
  return d_not_;
}
inline ::BehaviorPB::DecoratorNot* Node::release_d_not() {
  clear_has_d_not();
  ::BehaviorPB::DecoratorNot* temp = d_not_;
  d_not_ = NULL;
  return temp;
}
inline void Node::set_allocated_d_not(::BehaviorPB::DecoratorNot* d_not) {
  delete d_not_;
  d_not_ = d_not;
  if (d_not) {
    set_has_d_not();
  } else {
    clear_has_d_not();
  }
}

// optional .BehaviorPB.DecoratorLoop d_loop = 11;
inline bool Node::has_d_loop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Node::set_has_d_loop() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Node::clear_has_d_loop() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Node::clear_d_loop() {
  if (d_loop_ != NULL) d_loop_->::BehaviorPB::DecoratorLoop::Clear();
  clear_has_d_loop();
}
inline const ::BehaviorPB::DecoratorLoop& Node::d_loop() const {
  return d_loop_ != NULL ? *d_loop_ : *default_instance_->d_loop_;
}
inline ::BehaviorPB::DecoratorLoop* Node::mutable_d_loop() {
  set_has_d_loop();
  if (d_loop_ == NULL) d_loop_ = new ::BehaviorPB::DecoratorLoop;
  return d_loop_;
}
inline ::BehaviorPB::DecoratorLoop* Node::release_d_loop() {
  clear_has_d_loop();
  ::BehaviorPB::DecoratorLoop* temp = d_loop_;
  d_loop_ = NULL;
  return temp;
}
inline void Node::set_allocated_d_loop(::BehaviorPB::DecoratorLoop* d_loop) {
  delete d_loop_;
  d_loop_ = d_loop;
  if (d_loop) {
    set_has_d_loop();
  } else {
    clear_has_d_loop();
  }
}

// optional .BehaviorPB.DecoratorCounter d_counter = 12;
inline bool Node::has_d_counter() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Node::set_has_d_counter() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Node::clear_has_d_counter() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Node::clear_d_counter() {
  if (d_counter_ != NULL) d_counter_->::BehaviorPB::DecoratorCounter::Clear();
  clear_has_d_counter();
}
inline const ::BehaviorPB::DecoratorCounter& Node::d_counter() const {
  return d_counter_ != NULL ? *d_counter_ : *default_instance_->d_counter_;
}
inline ::BehaviorPB::DecoratorCounter* Node::mutable_d_counter() {
  set_has_d_counter();
  if (d_counter_ == NULL) d_counter_ = new ::BehaviorPB::DecoratorCounter;
  return d_counter_;
}
inline ::BehaviorPB::DecoratorCounter* Node::release_d_counter() {
  clear_has_d_counter();
  ::BehaviorPB::DecoratorCounter* temp = d_counter_;
  d_counter_ = NULL;
  return temp;
}
inline void Node::set_allocated_d_counter(::BehaviorPB::DecoratorCounter* d_counter) {
  delete d_counter_;
  d_counter_ = d_counter;
  if (d_counter) {
    set_has_d_counter();
  } else {
    clear_has_d_counter();
  }
}

// optional .BehaviorPB.DecoratorTimer d_timer = 13;
inline bool Node::has_d_timer() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Node::set_has_d_timer() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Node::clear_has_d_timer() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Node::clear_d_timer() {
  if (d_timer_ != NULL) d_timer_->::BehaviorPB::DecoratorTimer::Clear();
  clear_has_d_timer();
}
inline const ::BehaviorPB::DecoratorTimer& Node::d_timer() const {
  return d_timer_ != NULL ? *d_timer_ : *default_instance_->d_timer_;
}
inline ::BehaviorPB::DecoratorTimer* Node::mutable_d_timer() {
  set_has_d_timer();
  if (d_timer_ == NULL) d_timer_ = new ::BehaviorPB::DecoratorTimer;
  return d_timer_;
}
inline ::BehaviorPB::DecoratorTimer* Node::release_d_timer() {
  clear_has_d_timer();
  ::BehaviorPB::DecoratorTimer* temp = d_timer_;
  d_timer_ = NULL;
  return temp;
}
inline void Node::set_allocated_d_timer(::BehaviorPB::DecoratorTimer* d_timer) {
  delete d_timer_;
  d_timer_ = d_timer;
  if (d_timer) {
    set_has_d_timer();
  } else {
    clear_has_d_timer();
  }
}

// optional .BehaviorPB.DecoratorRand d_rand = 14;
inline bool Node::has_d_rand() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Node::set_has_d_rand() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Node::clear_has_d_rand() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Node::clear_d_rand() {
  if (d_rand_ != NULL) d_rand_->::BehaviorPB::DecoratorRand::Clear();
  clear_has_d_rand();
}
inline const ::BehaviorPB::DecoratorRand& Node::d_rand() const {
  return d_rand_ != NULL ? *d_rand_ : *default_instance_->d_rand_;
}
inline ::BehaviorPB::DecoratorRand* Node::mutable_d_rand() {
  set_has_d_rand();
  if (d_rand_ == NULL) d_rand_ = new ::BehaviorPB::DecoratorRand;
  return d_rand_;
}
inline ::BehaviorPB::DecoratorRand* Node::release_d_rand() {
  clear_has_d_rand();
  ::BehaviorPB::DecoratorRand* temp = d_rand_;
  d_rand_ = NULL;
  return temp;
}
inline void Node::set_allocated_d_rand(::BehaviorPB::DecoratorRand* d_rand) {
  delete d_rand_;
  d_rand_ = d_rand;
  if (d_rand) {
    set_has_d_rand();
  } else {
    clear_has_d_rand();
  }
}

// -------------------------------------------------------------------

// Tree_Editor

// required string desc = 1;
inline bool Tree_Editor::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tree_Editor::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tree_Editor::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tree_Editor::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Tree_Editor::desc() const {
  return *desc_;
}
inline void Tree_Editor::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Tree_Editor::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Tree_Editor::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tree_Editor::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* Tree_Editor::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Tree_Editor::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Tree

// optional .BehaviorPB.Tree.Editor editor = 1;
inline bool Tree::has_editor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tree::set_has_editor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tree::clear_has_editor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tree::clear_editor() {
  if (editor_ != NULL) editor_->::BehaviorPB::Tree_Editor::Clear();
  clear_has_editor();
}
inline const ::BehaviorPB::Tree_Editor& Tree::editor() const {
  return editor_ != NULL ? *editor_ : *default_instance_->editor_;
}
inline ::BehaviorPB::Tree_Editor* Tree::mutable_editor() {
  set_has_editor();
  if (editor_ == NULL) editor_ = new ::BehaviorPB::Tree_Editor;
  return editor_;
}
inline ::BehaviorPB::Tree_Editor* Tree::release_editor() {
  clear_has_editor();
  ::BehaviorPB::Tree_Editor* temp = editor_;
  editor_ = NULL;
  return temp;
}
inline void Tree::set_allocated_editor(::BehaviorPB::Tree_Editor* editor) {
  delete editor_;
  editor_ = editor;
  if (editor) {
    set_has_editor();
  } else {
    clear_has_editor();
  }
}

// required string name = 2;
inline bool Tree::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tree::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tree::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tree::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Tree::name() const {
  return *name_;
}
inline void Tree::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Tree::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Tree::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Tree::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Tree::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Tree::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .BehaviorPB.Node root = 3;
inline bool Tree::has_root() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Tree::set_has_root() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Tree::clear_has_root() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Tree::clear_root() {
  if (root_ != NULL) root_->::BehaviorPB::Node::Clear();
  clear_has_root();
}
inline const ::BehaviorPB::Node& Tree::root() const {
  return root_ != NULL ? *root_ : *default_instance_->root_;
}
inline ::BehaviorPB::Node* Tree::mutable_root() {
  set_has_root();
  if (root_ == NULL) root_ = new ::BehaviorPB::Node;
  return root_;
}
inline ::BehaviorPB::Node* Tree::release_root() {
  clear_has_root();
  ::BehaviorPB::Node* temp = root_;
  root_ = NULL;
  return temp;
}
inline void Tree::set_allocated_root(::BehaviorPB::Node* root) {
  delete root_;
  root_ = root;
  if (root) {
    set_has_root();
  } else {
    clear_has_root();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace BehaviorPB

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BehaviorPB::Action_Type>() {
  return ::BehaviorPB::Action_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BehaviorPB::Condition_Type>() {
  return ::BehaviorPB::Condition_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BehaviorPB::DecoratorCounter_Type>() {
  return ::BehaviorPB::DecoratorCounter_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BehaviorPB::NodeType>() {
  return ::BehaviorPB::NodeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BehaviorPB::ParallelPolicy>() {
  return ::BehaviorPB::ParallelPolicy_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BehaviorPB_2eproto__INCLUDED
